#!/usr/bin/env ruby

lib = File.expand_path(File.dirname(__FILE__) + '/../lib')
$LOAD_PATH.unshift(lib) if File.directory?(lib) && !$LOAD_PATH.include?(lib)

require 'cobweb'
require 'csv'
require 'slop'

include CobwebDSL

opts = Slop.parse(:help => true) do
  banner 'Usage: cobweb [options]'

  on 'url=', 'URL to start crawl from'
  on 'internal_urls=', 'Url patterns to include', :as => Array
  on 'external_urls=', 'Url patterns to exclude', :as => Array
  on 'seed_urls=', "Seed urls", :as => Array
  on 'crawl_limit=', 'Limit the crawl to a number of urls', :as => Integer
  on 'thread_count=', "Set the number of threads used", :as => Integer
  on 'timeout=', "Sets the timeout for http requests", :as => Integer

  on 'output=', 'Path to output data to'
  on 'script=', "Script to generate report"

  on 'v', 'verbose', 'Display crawl information'
  on 'd', 'debug', 'Display debug information'
  on 'w', 'web_statistics', 'Start web stats server'
end

if opts[:url]
  options = opts.to_hash.delete_if { |k, v| v.nil? || k == :url}
  options[:quiet] = !opts[:verbose]

  @crawler = CobwebCrawler.new({:cache_type => :full, :raise_exceptions => true}.merge(options))

  columns = nil

  CSV.open(opts[:output], "wb", :force_quotes => true) do |csv|
    statistics = @crawler.crawl(opts[:url]) do |page|
      puts "Reporting on #{page[:url]}"
      @doc = page[:body]


      page["link_rel"] = scope.link_tag_with_rel("canonical")["href"]
      page["title"] = scope.head_tag.title_tag.contents
      page["description"] = scope.meta_tag_with_name("description")["content"]
      page["keywords"] = scope.meta_tag_with_name("keywords")["content"]
      page["img tag count"] = scope.img_tags.count
      page["scripts in body"] = scope.body_tag.script_tags.count
      page["img without alt count"] = scope.img_tags.select{|node| node[:alt].nil? || node[:alt].strip().empty?}.count
      page["img alt"] = scope.img_tags_with_alt.map{|node| node[:alt]}.uniq


      if !columns
        columns = page.keys.reject{|k| k==:body || k==:links}
        csv << columns.map{|k| k.to_s}
      end
      csv << columns.map{|k| page[k]}
    end
  end

else
  puts opts
end
